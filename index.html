
<!DOCTYPE html>
<html lang="ja">
<head>
<link rel="manifest" href="manifest.json">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CORION</title>
<style>
  :root{--bg:#f4f6f8; --card:#ffffff; --accent:#1976d2; --muted:#666;--success:#ff0000;}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--bg);color:#000000}
  header{padding:18px;text-align:center;background:linear-gradient(90deg, #1976d2, #1976d2);color:white}
  header h1{margin:0;font-size:18px}
  .wrap{max-width:1100px;margin:18px auto;padding:12px}
  .controls{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;background:var(--card);padding:12px;border-radius:10px;align-items:center}
  .controls .row{display:flex;gap:8px;align-items:center}
  .controls label{font-size:14px;color:var(--muted)}
  .controls input[type=range]{width:100%}
  select,button,input[type=number]{padding:8px;border-radius:6px;border:1px solid #ddd;background:white;font-size:16px}
  button{cursor:pointer;border:none;background:var(--accent);color:white;padding:6px 12px;border-radius:6px;font-size:16px}
  button.secondary{background:#555}
  .flex{display:flex;gap:12px;align-items:center}
  #message{min-height:28px;margin:12px 0;padding:8px;border-radius:8px;background:rgba(33,150,243,0.06);color:#0b57a4;font-weight:600}
  .grid{display:grid;grid-template-columns:2fr 1fr 1fr;gap:12px;margin-top:12px}
  .card{background:var(--card);padding:12px;border-radius:10px;box-shadow:0 2px 6px rgba(0,0,0,0.05)}
  #courtArea{display:flex;flex-wrap:wrap;gap:12px}
  .court{min-width:160px;flex:1 1 160px;padding:10px;border-radius:8px;border:1px solid #e0e0e0;background:linear-gradient(180deg,#fff,#fbfdff);cursor:pointer}
  .court h3{margin:0 0 8px 0;font-size:15px}
  .court p{margin:0;font-weight:700}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px;border-bottom:1px solid #eee;text-align:center;font-size:14px}
  th{background:#fafafa;font-weight:700}
  .small{font-size:12px;color:var(--muted)}
  .muted{color:var(--muted)}
  .actions{display:flex;gap:8px;flex-wrap:wrap}
  .notice{color:var(--success);font-weight:700}
  footer{margin-top:18px;text-align:center;color:var(--muted);font-size:13px}

  @media (max-width:900px){
    .controls {
      grid-template-columns: 1fr;
    }
    .grid {
      grid-template-columns: 1fr;
    }

    /* スマホ用の試合形式選択ボックスのサイズ調整 */
    select#matchType {
      width: 100%;
      font-size: 16px;
      padding: 12px;
    }
  }

</style>
</head>
<body>
<header><h1>CORION for badminton or tennis<br>by Kaito Nagae</h1></header>

<div class="wrap">
  <div class="controls" aria-label="controls">
    <div class="row">
      <label>人数: <span id="playerCountLabel">1</span></label>
      <input id="playerCount" type="range" min="5" max="30" value="10" />
    </div>

    <div class="row">
      <label>コート数: <span id="courtCountLabel">1</span></label>
      <input id="courtCount" type="range" min="1" max="6" value="1" />
    </div>

    <div class="row">
      <label>試合形式</label>
      <select id="matchType"><option value="singles">シングルス</option><option value="doubles">ダブルス</option></select>
    </div>

    <div class="row actions">
      <button id="generateBtn">試合生成</button>
      <button id="nextAllBtn" class="secondary">今の試合をすべて更新</button>
      <button id="resetBtn" class="secondary">リセット</button>
      <button id="undoBtn" class="secondary">元に戻す↩</button>
      <button id="redoBtn" class="secondary">やり直す↪</button>
    </div>

    <div class="row actions">
      <button id="addBtn">プレイヤー追加</button>
      <input id="removeId" type="number" placeholder="削除番号" min="1" style="width:110px" />
      <button id="removeBtn">プレイヤー削除</button>
    </div>

    <div class="row small muted">
      <div></div>
    </div>
  </div>

  <div id="message" role="status"></div>

  <div class="grid">
    <div class="card">
      <h2 style="margin-top:0">コート</h2>
      <div id="courtArea" aria-live="polite"></div>
      <div class="small muted" style="margin-top:8px"></div>
    </div>

    <div class="card">
      <h2 style="margin-top:0">プレイヤー</h2>
      <table aria-live="polite">
        <thead><tr><th>番号</th><th>状態</th><th>試合数</th></tr></thead>
        <tbody id="playerTable"></tbody>
      </table>
      <div class="small muted" style="margin-top:8px"></div>
    </div>
  

    <div class="card">
      <h2 style="margin-top:0">ログ</h2>
      <table class="log">
        <thead>
          <tr><th>対戦</th><th>形式</th><th>コート</th></tr>
        </thead>
        <tbody id="matchLog"></tbody>
      </table>
    </div>
  </div>

  <footer>localStorage</footer>
</div>

<script>
/* ==========================
   データ構造・永続化
   ========================== */
const STORAGE_KEY = "match_system_v1";
let undoStack = [];
let redoStack = [];
let state = loadState();

/* 初期化 */
function defaultState(){
  return {
    players: [],          // Player objects
    availableIds: [],     // 空席番号（再利用優先）
    nextId: 1,            // 新規に割り当てる最大+1
    courts: [],           // 各コート { players: [ids], round: n, text: '' }
    matchHistory: [],     // [{round, type, players: [...]}]
    roundCounter: 1,       // ラウンド番号（増加）
  };
}

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw) return JSON.parse(raw);
  }catch(e){}
  const s = defaultState();
  return s;
}

function saveState(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

/* ==========================
   ヘルパー（Playerオブジェクト）
   Player: { id, matches, lastMatch, opponents:{id:count}, partners:{id:count}, lastPartner }
   ========================== */
function makePlayer(id){
  return { id, matches:0, lastMatch:0, opponents:{}, partners:{}, lastPartner:null };
}

/* ==========================
   UI要素
   ========================== */
const playerCountEl = document.getElementById("playerCount");
const playerCountLabel = document.getElementById("playerCountLabel");
const courtCountEl = document.getElementById("courtCount");
const courtCountLabel = document.getElementById("courtCountLabel");
const matchTypeEl = document.getElementById("matchType");
const messageEl = document.getElementById("message");
const courtArea = document.getElementById("courtArea");
const playerTable = document.getElementById("playerTable");

const addBtn = document.getElementById("addBtn");
const removeBtn = document.getElementById("removeBtn");
const removeIdInput = document.getElementById("removeId");
const generateBtn = document.getElementById("generateBtn");
const nextAllBtn = document.getElementById("nextAllBtn");
const resetBtn = document.getElementById("resetBtn");
const undoBtn = document.getElementById("undoBtn");
const redoBtn = document.getElementById("redoBtn");

/* 初期UI表示 */
playerCountLabel.textContent = playerCountEl.value;
courtCountLabel.textContent = courtCountEl.value;

/* ==========================
   UIレンダー
   ========================== */
function showMessage(msg, timeout=3000){
  messageEl.textContent = msg || "";
  if(timeout>0){ clearTimeout(showMessage._t); showMessage._t = setTimeout(()=>{ if(messageEl.textContent===msg) messageEl.textContent = ""; }, timeout); }
}

function renderPlayers(){
  const usedIds = state.players.map(p=>p.id);
  const maxId = Math.max(state.nextId-1, ...usedIds, 0);
  playerTable.innerHTML = "";
  const desiredRows = Math.max(maxId, parseInt(playerCountEl.value) || 5);
  for (let i = 1; i <= desiredRows; i++){
    const tr = document.createElement("tr");
    const p = state.players.find(x=>x.id===i);
    tr.innerHTML = `<td>#${i}</td>
                    <td>${p ? "<strong>参加中</strong>" : "空席"}</td>
                    <td>${p ? p.matches : "-"}</td>`;
    playerTable.appendChild(tr);
  }
}

function renderCourts(){
  courtArea.innerHTML = "";
  if(state.courts.length===0){
    courtArea.innerHTML = "<div class='small muted'>試合が生成されていません。試合生成 を押してください。</div>";
    return;
  }
  state.courts.forEach((c, idx)=>{
    const div = document.createElement("div");
    div.className = "court";
    const title = document.createElement("h3");
    title.textContent = `コート ${idx+1}`;
    const p = document.createElement("p");
    if(c.players && c.players.length>0){
      p.textContent = formatMatchText(c.players);
    } else {
      p.textContent = "待機中";
    }
    div.appendChild(title);
    div.appendChild(p);
    div.addEventListener("click", ()=>{ advanceCourt(idx); });
    courtArea.appendChild(div);
  });
}


function formatMatchText(players){
  if(!players || players.length===0) return "待機中";
  const names = players.map(id=>`#${id}`);
  if(players.length===2) return `${names[0]} vs ${names[1]}`;
  if(players.length===4) return `${names[0]} ${names[1]} vs ${names[2]} ${names[3]}`;
  return names.join(" vs ");
}

function renderMatchLog(){
  const logEl = document.getElementById("matchLog");
  if(!logEl) return;
  const rows = state.matchHistory.slice().reverse().map(entry =>
    `<tr>
      <td>${entry.text}</td>
      <td>${entry.type}</td>
      <td>コート${entry.court}</td>
    </tr>`
  ).join("");
  logEl.innerHTML = rows;
}

/* ==========================
   ユーティリティ: 利用可能プレイヤー抽出
   - 同時に行われている試合の参加者は除外
   ========================== */
function getActiveIdsOnCourts(excludeCourtIndex=null){
  const set = new Set();
  state.courts.forEach((c, idx)=>{
    if(idx===excludeCourtIndex) return;
    if(c.players) c.players.forEach(id=>set.add(id));
  });
  return set;
}

function getAvailablePlayers(excludeCourtIndex=null){
  const busy = getActiveIdsOnCourts(excludeCourtIndex);
  return state.players.filter(p=>!busy.has(p.id));
}

/* ==========================
   ソート基準ヘルパー
   優先順位（低い数を優先）：
   1) matches（少ない）
   2) lastMatch（古い => 小さい）
   3) id（最終手段）
   ========================== */
function sortByPriority(list){
  return list.slice().sort((a,b)=>{
    if(a.matches !== b.matches) return a.matches - b.matches;
    if(a.lastMatch !== b.lastMatch) return a.lastMatch - b.lastMatch;
    return a.id - b.id;
  });
}

/* ==========================
   対戦/ペア回数取得（修正版）
   ========================== */
function oppCount(a, b) {
  const aid = (a && typeof a === 'object') ? a.id : a;
  const bid = (b && typeof b === 'object') ? b.id : b;
  const pa = state.players.find(x => x.id === aid) || a; // a がすでにプレイヤーならそれを使う
  const map = (pa && pa.opponents) ? pa.opponents : {};
  return map[bid] || 0;
}

function partnerCount(a, b) {
  const aid = (a && typeof a === 'object') ? a.id : a;
  const bid = (b && typeof b === 'object') ? b.id : b;
  const pa = state.players.find(x => x.id === aid) || a;
  const map = (pa && pa.partners) ? pa.partners : {};
  return map[bid] || 0;
}

/* ==========================
   試合更新ロジック（試合成立後の履歴更新）
   ========================== */
function applyMatchResult(playersIds, courtIndex){
  const round = state.roundCounter++;
  const involved = playersIds.map(id=>state.players.find(p=>p.id===id));
  involved.forEach(p=>{
    p.matches = (p.matches||0) + 1;
    p.lastMatch = round;
  });

  if(playersIds.length === 2){
    const [a,b] = involved;
    a.opponents[b.id] = (a.opponents[b.id]||0) + 1;
    b.opponents[a.id] = (b.opponents[a.id]||0) + 1;
    a.lastPartner = a.lastPartner || null;
    b.lastPartner = b.lastPartner || null;
  } else if(playersIds.length === 4){
    const [p1,p2,p3,p4] = involved;
    p1.partners[p2.id] = (p1.partners[p2.id]||0) + 1;
    p2.partners[p1.id] = (p2.partners[p1.id]||0) + 1;
    p3.partners[p4.id] = (p3.partners[p4.id]||0) + 1;
    p4.partners[p3.id] = (p4.partners[p3.id]||0) + 1;

    [p1,p2].forEach(a=>{
      [p3,p4].forEach(b=>{
        a.opponents[b.id] = (a.opponents[b.id]||0) + 1;
        b.opponents[a.id] = (b.opponents[a.id]||0) + 1;
      });
    });

    p1.lastPartner = p2.id; p2.lastPartner = p1.id;
    p3.lastPartner = p4.id; p4.lastPartner = p3.id;
  }

  state.matchHistory.push({
    round,
    type:matchTypeEl.value,
    players: playersIds.slice(),
    court: courtIndex+1,
    text: formatMatchText(playersIds),
    time: Date.now() });
  saveState();
}

/* ==========================
   シングルス選出（条件完全対応版）
   ========================== */
function selectSinglesForCourt(excludeCourtIndex = null) {
  const available = getAvailablePlayers(excludeCourtIndex);
  if (available.length < 2) return null;

  // 経過時間を候補内で相対計算
  const maxLM = Math.max(...available.map(p => (p.lastMatch ?? -Infinity)));
  const age = p => (maxLM - (p.lastMatch ?? -Infinity)); // 大きいほど休んでいる

  // 1人目: 試合数 少 → 経過長 大 → 番号 小
  const sorted = available.slice().sort((a, b) => {
    if (a.matches !== b.matches) return a.matches - b.matches;
    const ag = age(a), bg = age(b);
    if (ag !== bg) return bg - ag;
    return a.id - b.id;
  });
  const p1 = sorted[0];

  // 2人目: p1との対戦回数 少 → 試合数 少 → 経過長 大 → 番号 小
  const candidates = available.filter(p => p.id !== p1.id);
  candidates.sort((a, b) => {
    const ca = oppCount(p1, a), cb = oppCount(p1, b);
    if (ca !== cb) return ca - cb;
    if (a.matches !== b.matches) return a.matches - b.matches;
    const ag = age(a), bg = age(b);
    if (ag !== bg) return bg - ag;
    return a.id - b.id;
  });

  const p2 = candidates[0];
  if (!p2) return null;
  return [p1.id, p2.id];
}

/* ==========================
   ダブルス選出（条件完全対応版）
   ========================== */
function selectDoublesForCourt(excludeCourtIndex = null) {
  const available = getAvailablePlayers(excludeCourtIndex);
  if (available.length < 4) return null;

  const maxLM = Math.max(...available.map(p => (p.lastMatch ?? -Infinity)));
  const age = p => (maxLM - (p.lastMatch ?? -Infinity));

  // 1人目
  const sorted = available.slice().sort((a, b) => {
    if (a.matches !== b.matches) return a.matches - b.matches;
    const ag = age(a), bg = age(b);
    if (ag !== bg) return bg - ag;
    return a.id - b.id;
  });
  const p1 = sorted[0];

  // 2人目（p1のペア）
  let p2cands = available.filter(p =>
    p.id !== p1.id &&
    p.id !== p1.lastPartner
  );
  if (p2cands.length === 0) {
    p2cands = available.filter(p => p.id !== p1.id);
  }
  p2cands.sort((a, b) => {
    const pa = partnerCount(p1, a), pb = partnerCount(p1, b);
    if (pa !== pb) return pa - pb;
    if (a.matches !== b.matches) return a.matches - b.matches;
    const ag = age(a), bg = age(b);
    if (ag !== bg) return bg - ag;
    return a.id - b.id;
  });
  const p2 = p2cands[0];
  if (!p2) return null;

  // 3人目（対戦相手1）
  const p3cands = available.filter(p =>
    p.id !== p1.id &&
    p.id !== p2.id &&
    p.id !== p1.lastPartner &&
    p.id !== p2.lastPartner
  );
  p3cands.sort((a, b) => {
    const minA = Math.min(oppCount(a, p1), oppCount(a, p2));
    const minB = Math.min(oppCount(b, p1), oppCount(b, p2));
    if (minA !== minB) return minA - minB;
    if (a.matches !== b.matches) return a.matches - b.matches;
    const ag = age(a), bg = age(b);
    if (ag !== bg) return bg - ag;
    return a.id - b.id;
  });
  const p3 = p3cands[0];
  if (!p3) return null;

  // 4人目（p3のペア）
  let p4cands = available.filter(p =>
    ![p1.id, p2.id, p3.id].includes(p.id) &&
    p.id !== p3.lastPartner
  );
  if (p4cands.length === 0) {
    p4cands = available.filter(p => ![p1.id, p2.id, p3.id].includes(p.id));
  }
  p4cands.sort((a, b) => {
    const pa = partnerCount(p3, a), pb = partnerCount(p3, b);
    if (pa !== pb) return pa - pb;
    if (a.matches !== b.matches) return a.matches - b.matches;
    const ag = age(a), bg = age(b);
    if (ag !== bg) return bg - ag;
    return a.id - b.id;
  });
  const p4 = p4cands[0];
  if (!p4) return null;

  return [p1.id, p2.id, p3.id, p4.id];
}

/* ==========================
   コート進行（単一コート）
   ========================== */
function advanceCourt(courtIndex){
  saveSnapshot();
  const type = matchTypeEl.value;
  const minPlayers = (type === "singles") ? (state.courts.length * 3) : (state.courts.length * 5);
  if(state.players.length < minPlayers){
    showMessage(`プレイヤー不足: ${type==='singles' ? 'シングルス' : 'ダブルス'} の最小人数は ${minPlayers} です`);
    return;
  }

  const firstRun = state.matchHistory.length === 0;
  if(firstRun){
    state.courts.forEach((court, idx)=>{
      if(court.players && court.players.length > 0){
      applyMatchResult(court.players, idx);
      }
    });
    assignInitialMatches();
    renderCourts();
    renderPlayers();
    showMessage("初回割当を ID 順で行いました");
    return;
  }

  const selection = (type==='singles')
    ? selectSinglesForCourt(courtIndex)
    : selectDoublesForCourt(courtIndex);
  if(!selection){
    showMessage("試合生成できる十分なプレイヤーがいません");
    return;
  }

  state.courts[courtIndex].players = selection.slice();
  state.courts[courtIndex].round = state.roundCounter;
  applyMatchResult(selection, courtIndex);
  saveState();
  renderCourts();
  renderPlayers();
  renderMatchLog();
  showMessage(`コート${courtIndex+1} を進めました: ${formatMatchText(selection)}`);
}

/* ==========================
   全コート一斉進行
   ========================== */
function nextAll(){
  saveSnapshot();
  const type = matchTypeEl.value;
  const minPlayers = (type === "singles") ? (state.courts.length * 3) : (state.courts.length * 5);
  if(state.players.length < minPlayers){
    showMessage(`プレイヤー不足: 最小人数 ${minPlayers} を満たしていません`);
    return;
  }
  for(let i=0;i<state.courts.length;i++){
    const selection = (type==='singles') ? selectSinglesForCourt(i) : selectDoublesForCourt(i);
    if(!selection) continue;
    state.courts[i].players = selection.slice();
    state.courts[i].round = state.roundCounter;
    applyMatchResult(selection, i);
  }
  saveState();
  renderCourts();
  renderPlayers();
  renderMatchLog();
  showMessage("今の試合をすべて終了しました");
}

/* ==========================
   初回ID順割当
   ========================== */
function assignInitialMatches(){
  const type = matchTypeEl.value;
  const perCourt = (type==='singles') ? 2 : 4;
  const sortedPlayers = state.players.slice().sort((a,b)=>a.id-b.id);
  state.courts = state.courts.map(()=>({players:[],round:null,text:''}));
  let idx = 0;
  for(let c=0;c<state.courts.length;c++){
    const take = sortedPlayers.slice(idx, idx+perCourt).map(p=>p.id);
    if(take.length === perCourt){
      state.courts[c].players = take;
      state.courts[c].round = state.roundCounter;
      applyMatchResult(take, c);
    } else {
      state.courts[c].players = [];
    }
    idx += perCourt;
  }
  saveState();
}

/* ==========================
   設定反映
   ========================== */
function applySettings(){
  const courtCount = parseInt(courtCountEl.value) || 1;
  while(state.courts.length < courtCount) state.courts.push({players:[],round:null,text:''});
  while(state.courts.length > courtCount) state.courts.pop();
  playerCountLabel.textContent = playerCountEl.value;
  courtCountLabel.textContent = courtCountEl.value;
  saveState();
  renderCourts();
  renderPlayers();
}

/* ==========================
   スライダーの人数を state に反映（試合生成実行時に適用）
   ========================== */
function applyPlayerCountFromSlider(){
  const target = parseInt(playerCountEl.value) || 5;
  const currentCount = state.players.length;

  if (currentCount < target){
    // 追加：空席番号を優先して再利用、なければ smallest unused id を使う
    const used = new Set(state.players.map(p => p.id));
    for (let i = currentCount; i < target; i++){
      let newId = 1;
      while (used.has(newId)) newId++;
      used.add(newId);
      const minMatches = state.players.length ? Math.min(...state.players.map(p=>p.matches||0)) : 0;
      const p = makePlayer(newId);
      p.matches = minMatches;
      state.players.push(p);
      state.availableIds = state.availableIds.filter(x=>x!==newId);
      state.nextId = Math.max(state.nextId, newId+1);
    }
  } else if (currentCount > target){
    // 減少：ID大のプレイヤーから削除（ただしコートに入っているプレイヤーは削除しない）
    const busy = new Set(state.courts.flatMap(c => c.players || []));
    const sortedDesc = state.players.slice().sort((a,b)=>b.id-a.id);
    let toRemove = currentCount - target;
    for (let p of sortedDesc){
      if (toRemove <= 0) break;
      if (busy.has(p.id)) continue;
      const idx = state.players.findIndex(x=>x.id===p.id);
      if (idx !== -1){
        state.players.splice(idx,1);
        if (!state.availableIds.includes(p.id)) state.availableIds.push(p.id);
        toRemove--;
      }
    }
    if (toRemove > 0){
      showMessage(`注意: ${toRemove} 名は現在試合に参加中のため削除できません`, 5000);
    }
    state.availableIds.sort((a,b)=>a-b);
  }
  // 保存・再描画は呼び出し元で行う
}

/* ==========================
   プレイヤー追加 / 削除（空席再利用）
   ========================== */
function addPlayer(){
  saveSnapshot();
  const targetMax = parseInt(playerCountEl.value) || 20;
  if(state.players.length >= targetMax){
    showMessage("満員のため追加できません");
    return;
  }
  const used = new Set(state.players.map(p=>p.id));
  let newId = 1;
  while(used.has(newId)) newId++;
  const minMatches = state.players.length ? Math.min(...state.players.map(p=>p.matches||0)) : 0;
  const p = makePlayer(newId);
  p.matches = minMatches;
  state.players.push(p);
  state.nextId = Math.max(state.nextId, newId+1);
  state.availableIds = state.availableIds.filter(x=>x!==newId);
  saveState();
  renderPlayers();
  showMessage(`新しく #${newId} のプレイヤーが追加されました`);
}

function removePlayer(){
  saveSnapshot();
  const id = parseInt(removeIdInput.value);
  if(!id){ showMessage("削除する番号を入力してください"); return; }
  const idx = state.players.findIndex(p=>p.id===id);
  if(idx === -1){ showMessage(`#${id} は存在しません`); return; }
  state.players.splice(idx,1);
  state.courts.forEach(c=>{ if(c.players) c.players = c.players.filter(pid=>pid !== id); });
  if(!state.availableIds.includes(id)) state.availableIds.push(id);
  state.availableIds.sort((a,b)=>a-b);
  saveState();
  renderPlayers();
  renderCourts();
  showMessage(`#${id} を削除しました（空席にしました）`);
}

/* ==========================
   イベントバインド
   ========================== */
playerCountEl.addEventListener("input", ()=>{ playerCountLabel.textContent = playerCountEl.value; renderPlayers(); });
courtCountEl.addEventListener("input", ()=>{ courtCountLabel.textContent = courtCountEl.value; applySettings(); });
matchTypeEl.addEventListener("change", ()=>{ renderPlayers(); });

addBtn.addEventListener("click", addPlayer);
removeBtn.addEventListener("click", removePlayer);

/* generate ボタン：先にスライダー人数反映を行うよう変更 */
generateBtn.addEventListener("click", ()=>{
  // ① スライダーの人数を state に反映
  applyPlayerCountFromSlider();
  // ② コート数に合わせて state.courts を調整
  const courtCount = parseInt(courtCountEl.value) || 1;
  while(state.courts.length < courtCount) state.courts.push({players:[],round:null,text:''});
  while(state.courts.length > courtCount) state.courts.pop();
  // ③ 最低人数チェック
  const type = matchTypeEl.value;
  const minPlayers = (type === "singles") ? (courtCount * 3) : (courtCount * 5);
  if(state.players.length < minPlayers){
    showMessage(`プレイヤー不足: 最小人数 ${minPlayers} を満たしてください`);
    saveState();
    renderPlayers();
    return;
  }
  // ④ 初回割当 or 空いているコートに割当
  if(state.matchHistory.length === 0){
    assignInitialMatches();
    renderMatchLog();
    showMessage("初回割当を ID 順で行いました");
  } else {
    for(let i=0;i<state.courts.length;i++){
      if(!state.courts[i].players || state.courts[i].players.length===0){
        const selection = (type==='singles') ? selectSinglesForCourt(i) : selectDoublesForCourt(i);
        if(selection){
          state.courts[i].players = selection.slice();
          state.courts[i].round = state.roundCounter;
          applyMatchResult(selection, i);
        }
      }
    }
    showMessage("試合を生成しました");
  }
  saveState();
  renderCourts();
  renderPlayers();
});

nextAllBtn.addEventListener("click", nextAll);
resetBtn.addEventListener("click", ()=>{
  if(!confirm("すべてのデータを初期化しますか？")) return;
  
  localStorage.removeItem(STORAGE_KEY);
  state = defaultState();
  
  undoStack = [];
  redoStack = [];
  
  renderCourts();
  renderPlayers();
  renderMatchLog();
  showMessage("データをリセットしました");
});
undoBtn.addEventListener("click", undo);
redoBtn.addEventListener("click", redo);

function saveSnapshot(){
  const snapshot = JSON.stringify(state);
  undoStack.push(snapshot);
  // 新しい操作が入ったら redoStack はクリア
  redoStack = [];
}

/* ページ読み込み時に既存stateから初期レンダリング */
(function init(){
  const desired = parseInt(playerCountEl.value);
  if(state.players.length === 0){
    for(let i=1;i<=desired;i++){
      state.players.push(makePlayer(i));
      state.nextId = i+1;
    }
    saveState();
  }
  applySettings();
  renderPlayers();
  renderCourts();
  renderMatchLog();
  saveSnapshot(); // ★ 最初の状態を積む
})();

function undo(){
  if (undoStack.length === 0){
    showMessage("元に戻せる状態がありません");
    return;
  }
  redoStack.push(JSON.stringify(state));
  const snapshot = undoStack.pop();
  state = JSON.parse(snapshot);
  saveState();
  renderCourts();
  renderPlayers();
  renderMatchLog();
  showMessage("元に戻しました");
}

function redo(){
  if (redoStack.length === 0){
    showMessage("やり直せる状態がありません");
    return;
  }
  undoStack.push(JSON.stringify(state));
  const snapshot = redoStack.pop();
  state = JSON.parse(snapshot);
  saveState();
  renderCourts();
  renderPlayers();
  renderMatchLog();
  showMessage("やり直しました");
}

</script>
</body>
</html>
